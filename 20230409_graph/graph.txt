									sianke1991
0. 그래프: 노드(정점, Vertex)와 간선(Edge)로 이루어진 자료구조
1. 차수(degree): 특정 노드에 대해 간선으로 연결된 노드의 개수
2. Undirected Graph: 간선에 방향이 없는 그래프 (반대는 Directed Graph)
3. Outdegree: 간선에 방향이 있는 그래프에 대해서 특정 노드로부터 나가는 간선의 개수 (반대로 특정 노드로 들어오는 간선의 개수는 Indegree)
4. Cyclic Graph: 한 노드에서 시작해서 유턴하지 않고(...) 시작했던 노드로 돌아올 수 있는 그래프 (반대는 Acyclic Graph)
5. Complete Graph: 모든 노드 쌍에 대해 그 쌍을 연결하는 간선이 존재하는 그래프
6. Connected Graph: 둘 이상으로 분리되지 않는 그래프 (모든 노드 쌍에 대해 간선(들)로 연결이 되는 그래프)
7. Loop: 서로 다른 두 노드가 아닌 한 노드를 연결하는 간선 (≠ Cycle)
8. Simple Graph: 두 정점 사시의 간선이 1개 이하이고, 루프가 존재하지 않는 그래프
  (인접행렬로 표현한 경우 모든 원소는 0 또는 1이고, 대각 성분은 0이 되는 그래프)
9. 노드는 관습상 1번부터 시작한다. (0번 노드는 생각하지 않는다.)
10. 인접행렬: V개의 노드에 대해 V*V 행렬로 간선의 정보를 담은 행렬 
adj[u][v] := u 노드에서 시작해서 v 노드로 끝나는 간선의 개수
11. 인접리스트: V개의 노드에 대해 V개의 리스트를 만들어서 각 노드에서 출발하는 간선의 정보를 담음
adj[u]:= u 노드에서 시작해서 도착하는 노드들 목록

		인접행렬		인접리스트
----------------------------------------------------------------------
공간복잡도	O(V²)			O(V+E)
----------------------------------------------------------------------
정점 u, v가
연결되어있는지	O(1)			O(min(deg(u), deg(v))) => 무방향 그래프일 경우
확인할 때의 
시간복잡도
----------------------------------------------------------------------
정점 v와 연결된
모든 정점을 	O(V)			O(dev(V))
확인시
시간복잡도
----------------------------------------------------------------------
효율적인 상황	두 점의 연결 여부를	특정 정점에 연결된 모든 정점을 자주 확인할 때
		자주 확인할 때,		E가 V²보다 훨씬 작을 때 (저장 공간을 절약할 수 있다.)
		E가 V²에 가까울 때	(행렬로 표현할 경우 희소행렬이 될 때)
		(완전 그래프에 가까울 때)
----------------------------------------------------------------------
eg. V=10만, E=20만인 경우 인접리스트가, V=100, E=7000인 경우 인접행렬을 사용한다.
앞으로 인접리스트 형식을 더 자주 사용하지만 알고리즘에 따라 인접행렬을 사용해야 할 때도 있다.
12. BFS, DFS: 모든 노드를 방문하는 것을 목적으로 하는 알고리즘으로 BFS는 너비를 우선으로, DFS는 깊이를 우선으로 탐색한다.
13. BFS, DFS의 시간복잡도: 인접행렬을 사용할 경우 시간복잡도 O(V²), 인접리스트를 사용할 경우 시간복잡도 O(V+E)가 된다. 인접행렬을 사용할 경우 한 노드에 대해 인접한 노드를 살피는데 O(V)가 되고, 이 작업을 V개의 노드에 대해 반복해야 하므로 최종 시간복잡도는 O(V²)가 된다. 인접리스트를 사용할 경우 각 간선에 대해 작업을 하므로 시간복잡도에 E 항이 들어간다. 단, 노드 방문처리 및 확인 때문에 O(E)가 아니라 O(V+E)가 된다.