radix sort: 기수정렬

예를 들어 다음 10 개의 정수를 정렬한다.
497, 164, 312, 896, 334, 478, 199, 120, 610, 863

step1. 일의 자리에 따라 정렬한다. (일의 자리가 같은 경우 먼저 나오는 값을 왼쪽에 둔다.)
[120, 640], [312], [863], [164, 334], [896], [497], [478], [199]
=> 이렇게 정렬함으로써 백의 자리와 십의 자리가 같은 두 수가 존재하는 경우 
십의 자리와 백의 자리에 따라 정렬하더라도 정렬의 순서를 잡아줄 수 있다.

step2. (위에서 정렬한 결과를 사용하여) 십의 자리에 따라 정렬한다. (십의 자리가 같은 경우 먼저 나오는 값을 왼쪽에 둔다.)
[312], [120], [334], [640], [863, 164], [478], [896, 497, 199]

step3. (위에서 정렬한 결과를 사용하여) 백의 자리에 따라 정렬한다. (백의 자리가 같은 경우 먼저 나오는 값을 왼쪽에 둔다.)
[120, 164, 199], [312, 334], [478, 497], [640], [863, 896]

위 예시의 경우 백의 자리가 수의 대소를 비교하는데 가장 중요한 역할을 한다. 그렇기 때문에 해당 작업을 맨 마지막에 수행한다.
백의 자리가 같은 두 수의 경우 십의 자리가 더 큰 수가 뒤에 와야 하는데, 그 작업은 바로 전 과정에서 수행되었다.

기수정렬은 counting sort: 계수정렬를 응용한 버전이라고 할 수 있다. 계수 정렬은 시간 복잡도가
O(N+k)
N: 정렬하는 배열의 길이
k: 정렬하는 배열에 들어가는 값의 범위
이다. 기수 정렬은 시간 복잡도가
O(d(k+N))
d: 자리 개수 (위 예시 기준 3 단계에 걸쳐서 정렬을 했기 때문에 d=3)
k: 도수 개수 (위 예시 기준 각 자리에 올 수 있는 값의 경우의 수이므로 k=10)
N: 정렬하는 배열의 길이
이다. k, 즉 정렬하고자 하는 값의 범위가 넓어지면 기수정렬이 계수정렬에 비해 어드밴티지를 얻게 된다.